//##########################################################################
//
// This program is part of Zenoss Core, an open source monitoring platform.
// Copyright (C) 2010, Zenoss Inc.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 as published by
// the Free Software Foundation.
//
// For complete information please visit: http://www.zenoss.com/oss/
//
//##########################################################################

import "messaging.proto";
import "model.proto";
import "states.proto";
import "util.proto";

package org.zenoss.protobufs.zep;

message EventActor {
    optional org.zenoss.protobufs.model.ModelElementType element_type_id = 1;
    optional string element_uuid = 2;
    optional string element_identifier = 3;
    optional org.zenoss.protobufs.model.ModelElementType element_sub_type_id = 4;
    optional string element_sub_uuid = 5;
    optional string element_sub_identifier = 6;
}

message EventDetail {
    enum EventDetailMergeBehavior {
        REPLACE = 1; // Replace old values with new values
        APPEND = 2; // Append new values to old values
        UNIQUE = 3; // Append new values to old values and remove duplicate values
    }
    required string name = 1;
    repeated string value = 2;
    // When de-duping events or updating details on an existing event, if an existing
    // detail is found in the event with the same name, this enum controls how the
    // detail values should be merged.
    optional EventDetailMergeBehavior merge_behavior = 3 [default = REPLACE];
}

message EventDetailSet {
    repeated EventDetail details = 1;
}

// Tag events with arbitrary UUIDs. Tags are used for event rainbows and filtering.
message EventTag {
    required string type = 1;
    required string uuid = 2;
}

// Notes added to an event (formerly event log).
message EventNote {
    optional string uuid = 1;
    optional string user_uuid = 2;
    optional string user_name = 3;
    optional uint64 created_time = 4;
    required string message = 5;
}

enum EventSeverity {
    SEVERITY_CLEAR = 0;
    SEVERITY_DEBUG = 1;
    SEVERITY_INFO = 2;
    SEVERITY_WARNING = 3;
    SEVERITY_ERROR = 4;
    SEVERITY_CRITICAL = 5;
}

enum SyslogPriority {
    SYSLOG_PRIORITY_EMERG = 0;
    SYSLOG_PRIORITY_ALERT = 1;
    SYSLOG_PRIORITY_CRIT = 2;
    SYSLOG_PRIORITY_ERR = 3;
    SYSLOG_PRIORITY_WARNING = 4;
    SYSLOG_PRIORITY_NOTICE = 5;
    SYSLOG_PRIORITY_INFO = 6;
    SYSLOG_PRIORITY_DEBUG = 7;
}

enum EventStatus {
    STATUS_NEW = 1;
    STATUS_ACKNOWLEDGED = 2;
    STATUS_SUPPRESSED = 3;
    STATUS_CLOSED = 4; // Closed by the user.
    STATUS_CLEARED = 5; // Closed by a matching clear event.
    STATUS_DROPPED = 6; // Dropped via a transform.
    STATUS_AGED = 7; // Closed via automatic aging.
}

// Represents an event that is sent from zenhub
message RawEvent {
    required string uuid = 1;
    required uint64 created_time = 2;
    optional string fingerprint = 3;
    optional string event_class = 4;
    optional string event_class_key = 5;
    optional EventActor actor = 6;
    optional string summary = 7;
    optional string message = 8;
    optional EventSeverity severity = 9;
    optional string event_key = 10;
    optional string event_group = 11;
    optional string agent = 12;
    optional SyslogPriority syslog_priority = 13;
    optional uint32 syslog_facility = 14;
    optional uint32 nt_event_code = 15;
    optional string monitor = 16;
    repeated EventDetail details = 17;
}

// Represents an event that is sent to ZEP for processing.
// This is a temporary bridge between zeneventd and ZEP
message ZepRawEvent {
    required RawEvent raw_event = 1;
    repeated string clear_event_class = 2;
    optional EventStatus status = 3 [default = STATUS_NEW];
    repeated EventTag tags = 4;
}

// Represents an individual event occurrence (processed RawEvent).
message Event {
    optional string uuid = 1;
    optional uint64 created_time = 2;
    optional string fingerprint = 3;
    optional string event_class = 4;
    optional string event_class_key = 5;
    optional string event_class_mapping_uuid = 6;
    optional EventActor actor = 7;
    optional string summary = 8;
    optional string message = 9;
    optional EventSeverity severity = 10 [default = SEVERITY_INFO];
    optional string event_key = 12;
    optional string event_group = 13;
    optional string agent = 14;
    optional SyslogPriority syslog_priority = 15;
    optional uint32 syslog_facility = 16;
    optional uint32 nt_event_code = 17;
    optional string monitor = 18;
    repeated EventDetail details = 19;
    repeated EventTag tags = 20;
}

// Represents a summary of an event (based on fingerprint).
message EventSummary {
    optional string uuid = 1;
    // Typically contains only the most recent occurrence.
    repeated Event occurrence = 2;
    optional EventStatus status = 3 [default = STATUS_NEW];
    optional uint64 first_seen_time = 4;
    optional uint64 status_change_time = 5;
    optional uint64 last_seen_time = 6;
    optional uint32 count = 7 [default = 1];
    optional string acknowledged_by_user_uuid = 8;
    optional string acknowledged_by_user_name = 9;
    optional string cleared_by_event_uuid = 10;
    repeated EventNote notes = 11;
    optional uint64 update_time = 12;
}

// Both from and to are inclusive. If 'from' is not specified, then 'from' is
// considered as negative infinity. If 'to' is not specified, then 'to' is
// considered positive infinity.
message NumberRange {
    optional sint64 from = 1;
    optional sint64 to = 2;
}

enum FilterOperator {
    OR = 1;
    AND = 2;
}

message EventTagFilter {
    optional FilterOperator op = 1 [default = OR];
    repeated string tag_uuids = 2;
}

// Values will be searched as an exact match unless otherwise
// specified by their detail type.
// Strings: Exact or wildcare if * or ?
// Numeric: Exact or range if in the form of M:, :N, or M:N
message EventDetailFilter {
    // All details in this filter share the FilterOperator specified.
    required string key = 1;
    repeated string value = 2;
    optional FilterOperator op = 3 [default = OR];
}

message EventFilter {
    repeated EventSeverity severity = 1;
    repeated EventStatus status = 2;

    // Accepted event_class queries:
    //
    //   /Class/NameFoo  -> Matches event_class "/Class/NameFoo" exactly.
    //   /Class/NameFoo/ -> Matches event_class "/Class/NameFoo" and any subclasses ("/Class/NameFoo/Bar" but not
    //                      "/Class/NameFooBar").
    //   /Class/NameFoo* -> Matches any event_class starting with "/Class/NameFoo".
    //   NameFoo         -> Matches any event_class with "NameFoo" as a component of the event class, i.e.
    //                      "/Class/NameFoo" or "/NameFoo" but not "/Class/NameFooBar".
    //   NameFoo*        -> Matches any event_class with a component that starts with "NameFoo", i.e. "/Class/NameFoo"
    //                      or "/NameFooBar".
    //   NameFoo/Bar     -> Matches any event class with the components in order "NameFoo" and "Bar". This matches
    //                      "/Class/NameFoo/Bar" but not "/Class/Bar/NameFoo".
    //   N*/B*           -> Matches any event class with components with prefix 'N' and 'B' in order.
    //
    // NOTE: All searches beginning with a '/' search the entire event class, otherwise the tokenized event class is
    //       searched.
    repeated string event_class = 3;

    repeated org.zenoss.protobufs.util.TimestampRange first_seen = 4;
    repeated org.zenoss.protobufs.util.TimestampRange last_seen = 5;
    repeated org.zenoss.protobufs.util.TimestampRange status_change = 6;
    repeated org.zenoss.protobufs.util.TimestampRange update_time = 7;
    repeated NumberRange count_range = 8;
    repeated string element_identifier = 9;
    repeated string element_sub_identifier = 10;
    repeated string uuid = 11; // event summary uuid

    // All search terms support wildcard queries ('*' and '?'). Phrases are supported within a query by enclosing
    // the phrase to be searched within double quotes.
    repeated string event_summary = 12;
    repeated string acknowledged_by_user_name = 13;
    repeated EventTagFilter tag_filter = 14;
    repeated EventDetailFilter details = 15;
    repeated string fingerprint = 16;
    repeated string agent = 17;
    repeated string monitor = 18;

    // operator is used for all fields on this filter. Repeateds are grouped and ORed.
    optional FilterOperator operator = 19 [default = AND];
    
    repeated EventFilter subfilter = 20;
}

message EventSort {
    enum Field {
        SEVERITY = 1;
        STATUS = 2;
        EVENT_CLASS = 3;
        FIRST_SEEN = 4;
        LAST_SEEN = 5;
        STATUS_CHANGE = 6;
        COUNT = 7;
        ELEMENT_IDENTIFIER = 8;
        ELEMENT_SUB_IDENTIFIER = 9;
        EVENT_SUMMARY = 10;
        UPDATE_TIME = 11;
        ACKNOWLEDGED_BY_USER_NAME = 12;
        AGENT = 13;
        MONITOR = 14;
        UUID = 15;
        FINGERPRINT = 16;
        DETAIL = 17; // detail key must be set, specified below.
    }

    enum Direction {
        ASCENDING = 1;
        DESCENDING = 2;
    }

    required Field field = 1;
    optional Direction direction = 2 [default = ASCENDING];
    optional string detail_key = 3;
}

// message for requesting event summaries.
message EventSummaryRequest {
    optional EventFilter event_filter = 1;
    optional EventFilter exclusion_filter = 2;
    repeated EventSort sort = 3;
    optional uint32 limit = 4 [default = 1000];
    optional uint32 offset = 5;
}

// message for response for EventSummaryRequest
message EventSummaryResult {
    repeated EventSummary events = 1;
    optional uint32 limit = 2;
    // Will be set to offset + limit if results remain, otherwise unset.
    optional uint32 next_offset = 3;
    optional uint32 total = 4;
}

// Properties which can be modified on an event summary
// This is passed with every EventSummaryUpdateRequest.
message EventSummaryUpdate {
    optional EventStatus status = 1;
    optional string acknowledged_by_user_uuid = 2;
    optional string acknowledged_by_user_name = 3;
}


// POST to events/search that starts a saved search.
// Returns a 204 created if successful.
// DELETE to the uri in order to expire the search before the timeout.
message EventQuery {
    optional EventFilter event_filter = 1;
    optional EventFilter exclusion_filter = 2;
    repeated EventSort sort = 3;
    optional uint32 timeout = 4 [default=60];
}

// once a query has been established, you will have the event_query_uuid
// with which you will need to make subsequent update requests.
message EventSummaryUpdateRequest {
    optional string event_query_uuid = 1;
    required EventSummaryUpdate update_fields = 2;
    optional uint32 offset = 3 [default = 0];
    optional uint32 limit = 4 [default = 100];
}

message EventSummaryUpdateResponse {
    // Message used to update the next sequence in the collection.
    // This is unset if there are no events left to update.
    optional EventSummaryUpdateRequest next_request = 1;
    optional uint32 total = 2; // Never changes - just informational.
    required uint32 updated = 3; // The number of events updated in this batch.
}

message EventDetailItem {
    enum EventDetailType {
        STRING = 1;
        INTEGER = 2;
        FLOAT = 3;
        LONG = 4;
        DOUBLE = 5;
    }
    required string key = 1;
    optional EventDetailType type = 2 [default = STRING];
    optional string name = 3;
    // @TODO: add renderer, filter, field definition, etc.
}

// GET on some zep uri will return this proto as a response
message EventDetailItemSet {
    repeated EventDetailItem details = 1;
}

// Event Triggers
enum RuleType {
    RULE_TYPE_JYTHON = 1;
}

// The content is evaluated by a "ScriptEngine" for RuleType and checked against the event
message Rule {
    required int32 api_version = 1;
    required RuleType type = 2;
    required string source = 3;
}

message EventTriggerSubscription {
    optional string uuid = 1;
    // Wait this amount of time for a possible clear before sending a signal
    optional int32 delay_seconds = 2;
    // After first signal, wait this amount of time before sending a signal again (0 for no repeating)
    optional int32 repeat_seconds = 3;
    // should we send a signal on every occurrence of an event or only on the first
    optional bool send_initial_occurrence = 4 [default = true];
    // id of subscriber
    required string subscriber_uuid = 5;
    // id of trigger to subscribe to
    required string trigger_uuid = 6;
}

message EventTriggerSubscriptionSet {
    repeated EventTriggerSubscription subscriptions = 1;
}

message EventTrigger {
    optional string uuid = 1;
    optional string name = 2;
    optional bool enabled = 3 [default = true];

    // If rule matches event, start responding to subscriptions
    required Rule rule = 4;

    repeated EventTriggerSubscription subscriptions = 5;
}

message EventTriggerSet {
    repeated EventTrigger triggers = 1;
}

// A signal is sent because a Trigger rule matched an event and we
// waited for a EventTriggerSubscription.delay_seconds amount of time before
// sending the signal. Action is taken immediately for any signal received.
message Signal {
    required string uuid = 1;
    required uint64 created_time = 2;
    required string trigger_uuid = 3;
    required string subscriber_uuid = 4;
    // If this is signal clears all previous signals
    optional bool clear = 5 [default = false];
    optional EventSummary event = 6;
    optional string message = 7;
}

message EventTagSeverity {
    required EventSeverity severity = 1;
    optional uint32 count = 2;
}

message EventTagSeverities {
    required string tag_uuid = 1;
    repeated EventTagSeverity severities = 2;
    // The total number of event occurrences for this tag_uuid
    optional uint32 total = 3;
}

message EventTagSeveritiesSet {
    repeated EventTagSeverities severities = 1;
}

message ZepConfig {
    // Events with a lower severity than this are selected for aging (along
    // with event_age_interval_minutes). If you specify SEVERITY_CLEAR for
    // this setting, it disables event aging.
    optional EventSeverity event_age_disable_severity = 1 [default = SEVERITY_ERROR];

    // The number of minutes that elapse from the last time an event was seen
    // until it is a candidate for event aging. Setting this to 0 disables
    // event aging.
    optional uint32 event_age_interval_minutes = 2 [default = 240];

    // The number of days since a closed event was last seen before it is moved
    // to the event archive. The minimum value is 1 and the maximum value is 30.
    optional uint32 event_archive_interval_days = 3 [default = 3];

    // The number of days that events in the event archive are saved. By default
    // they are kept in the archive for 90 days. The minimum value is 1 and the
    // maximum value is determined by the range of event archive partitions. With
    // the default configuration, the maximum value is 1000 days.
    optional uint32 event_archive_purge_interval_days = 4 [default = 90];

    // The number of days that event occurrences are saved. By default, they are
    // kept for 30 days. The minimum value is 1 and the maximum value is determined
    // by the range of event occurrence partitions. With the default configuration,
    // the maximum value is 250 days.
    optional uint32 event_occurrence_purge_interval_days = 5 [default = 30];
}
